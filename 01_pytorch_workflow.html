<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>01 - PyTorch 워크플로우 – 파이토치 딥러닝 입문</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./02_pytorch_classification.html" rel="next">
<link href="./00_pytorch_fundamentals.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-841b73d05e5bc75123d26cb7b2f11c52.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./01_pytorch_workflow.html"><span class="chapter-title">01 - PyTorch 워크플로우</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">파이토치 딥러닝 입문</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">딥러닝을 위한 PyTorch 배우기</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00_pytorch_fundamentals.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">00 - PyTorch 기초</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01_pytorch_workflow.html" class="sidebar-item-text sidebar-link active"><span class="chapter-title">01 - PyTorch 워크플로우</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_pytorch_classification.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">02 - PyTorch 신경망 분류</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03_pytorch_computer_vision.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">03 - PyTorch 컴퓨터 비전</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04_pytorch_custom_datasets.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">04 - PyTorch 사용자 정의 데이터셋</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05_pytorch_going_modular.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">05 - PyTorch 모듈화</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06_pytorch_transfer_learning.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">06 - PyTorch 전이 학습</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07_pytorch_experiment_tracking.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">07 - PyTorch 실험 추적</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08_pytorch_paper_replicating.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">08 - PyTorch 논문 복제</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09_pytorch_model_deployment.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">09 - PyTorch 모델 배포</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">참고 문헌</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#이번-장에서-다룰-내용" id="toc-이번-장에서-다룰-내용" class="nav-link active" data-scroll-target="#이번-장에서-다룰-내용">이번 장에서 다룰 내용</a></li>
  <li><a href="#도움을-받을-수-있는-곳" id="toc-도움을-받을-수-있는-곳" class="nav-link" data-scroll-target="#도움을-받을-수-있는-곳">도움을 받을 수 있는 곳</a></li>
  <li><a href="#데이터-준비-및-로드" id="toc-데이터-준비-및-로드" class="nav-link" data-scroll-target="#데이터-준비-및-로드">1. 데이터 (준비 및 로드)</a>
  <ul class="collapse">
  <li><a href="#데이터를-훈련-세트와-테스트-세트로-분할하기" id="toc-데이터를-훈련-세트와-테스트-세트로-분할하기" class="nav-link" data-scroll-target="#데이터를-훈련-세트와-테스트-세트로-분할하기">데이터를 훈련 세트와 테스트 세트로 분할하기</a></li>
  </ul></li>
  <li><a href="#모델-구축" id="toc-모델-구축" class="nav-link" data-scroll-target="#모델-구축">2. 모델 구축</a>
  <ul class="collapse">
  <li><a href="#pytorch-모델-구축-필수-요소" id="toc-pytorch-모델-구축-필수-요소" class="nav-link" data-scroll-target="#pytorch-모델-구축-필수-요소">PyTorch 모델 구축 필수 요소</a></li>
  <li><a href="#pytorch-모델의-내용-확인하기" id="toc-pytorch-모델의-내용-확인하기" class="nav-link" data-scroll-target="#pytorch-모델의-내용-확인하기">PyTorch 모델의 내용 확인하기</a></li>
  <li><a href="#torch.inference_mode를-사용하여-예측하기" id="toc-torch.inference_mode를-사용하여-예측하기" class="nav-link" data-scroll-target="#torch.inference_mode를-사용하여-예측하기"><code>torch.inference_mode()</code>를 사용하여 예측하기</a></li>
  <li><a href="#모델-저장-및-로드" id="toc-모델-저장-및-로드" class="nav-link" data-scroll-target="#모델-저장-및-로드">6.5 모델 저장 및 로드</a></li>
  </ul></li>
  <li><a href="#연습-문제" id="toc-연습-문제" class="nav-link" data-scroll-target="#연습-문제">연습 문제</a></li>
  <li><a href="#추가-학습-자료" id="toc-추가-학습-자료" class="nav-link" data-scroll-target="#추가-학습-자료">추가 학습 자료</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-title">01 - PyTorch 워크플로우</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><a href="https://colab.research.google.com/github/mrdbourke/pytorch-deep-learning/blob/main/01_pytorch_workflow.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a></p>
<p>머신러닝과 딥러닝의 본질은 과거의 일부 데이터를 가져와서 패턴을 발견하기 위한 알고리즘(신경망 등)을 구축하고, 발견된 패턴을 사용하여 미래를 예측하는 것입니다.</p>
<p>이를 수행하는 방법은 많으며 항상 새로운 방법이 발견되고 있습니다.</p>
<p>하지만 작게 시작해 봅시다.</p>
<p>직선으로 시작하면 어떨까요?</p>
<p>그리고 그 직선에 맞는 모델을 PyTorch로 구축할 수 있는지 확인해 보겠습니다.</p>
<section id="이번-장에서-다룰-내용" class="level2">
<h2 class="anchored" data-anchor-id="이번-장에서-다룰-내용">이번 장에서 다룰 내용</h2>
<p>이 모듈에서는 표준 PyTorch 워크플로우를 다룰 것입니다(필요에 따라 자르고 변경할 수 있지만 주요 단계의 윤곽을 다룹니다).</p>
<p><img src="https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/01_a_pytorch_workflow.png" width="900" alt="pyTorch 워크플로우 순서도"></p>
<p>지금은 이 워크플로우를 사용하여 간단한 직선을 예측할 것이지만, 워크플로우 단계는 작업 중인 문제에 따라 반복되고 변경될 수 있습니다.</p>
<p>구체적으로 다음 내용을 다룹니다:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th><strong>주제</strong></th>
<th><strong>내용</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>1. 데이터 준비하기</strong></td>
<td>데이터는 거의 무엇이든 될 수 있지만, 시작하기 위해 간단한 직선을 만들 것입니다.</td>
</tr>
<tr class="even">
<td><strong>2. 모델 구축하기</strong></td>
<td>여기에서는 데이터의 패턴을 학습할 모델을 만들고, <strong>손실 함수(loss function)</strong>, <strong>옵티마이저(optimizer)</strong>를 선택하고 <strong>훈련 루프(training loop)</strong>를 구축할 것입니다.</td>
</tr>
<tr class="odd">
<td><strong>3. 데이터에 모델 맞추기 (훈련)</strong></td>
<td>데이터와 모델이 준비되었으므로, 이제 모델이 (<strong>훈련</strong>) 데이터에서 패턴을 찾도록 (시도하게) 해봅시다.</td>
</tr>
<tr class="even">
<td><strong>4. 예측 및 모델 평가 (추론)</strong></td>
<td>모델이 데이터에서 패턴을 찾았으니, 그 결과를 실제 (<strong>테스트</strong>) 데이터와 비교해 봅시다.</td>
</tr>
<tr class="odd">
<td><strong>5. 모델 저장 및 불러오기</strong></td>
<td>모델을 다른 곳에서 사용하거나 나중에 다시 사용하고 싶을 수 있습니다. 여기에서 그 방법을 다룹니다.</td>
</tr>
<tr class="even">
<td><strong>6. 전체 과정 합치기</strong></td>
<td>위의 모든 내용을 하나로 합쳐 봅시다.</td>
</tr>
</tbody>
</table>
</section>
<section id="도움을-받을-수-있는-곳" class="level2">
<h2 class="anchored" data-anchor-id="도움을-받을-수-있는-곳">도움을 받을 수 있는 곳</h2>
<p>이 과정의 모든 자료는 <a href="https://github.com/mrdbourke/pytorch-deep-learning">GitHub</a>에서 확인할 수 있습니다.</p>
<p>문제가 발생하면 해당 페이지의 <a href="https://github.com/mrdbourke/pytorch-deep-learning/discussions">Discussions 페이지</a>에서 질문할 수 있습니다.</p>
<p>또한 PyTorch와 관련된 모든 것에 대해 매우 도움이 되는 장소인 <a href="https://discuss.pytorch.org/">PyTorch 개발자 포럼</a>도 있습니다.</p>
<p>먼저 다룰 내용을 나중에 참조할 수 있도록 딕셔너리에 넣어 보겠습니다.</p>
<div id="cell-4" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>what_were_covering <span class="op">=</span> {<span class="dv">1</span>: <span class="st">"데이터 (준비 및 로드)"</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: <span class="st">"모델 구축"</span>,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: <span class="st">"데이터에 모델 맞추기 (훈련)"</span>,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span>: <span class="st">"예측 및 모델 평가 (추론)"</span>,</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">5</span>: <span class="st">"모델 저장 및 로드"</span>,</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">6</span>: <span class="st">"전체 과정 합치기"</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>이제 이 모듈에 필요한 것들을 임포트해 보겠습니다.</p>
<p><code>torch</code>, <code>torch.nn</code>(<code>nn</code>은 신경망을 뜻하며 이 패키지에는 PyTorch에서 신경망을 구축하기 위한 기본 구성 요소가 들어 있습니다) 및 <code>matplotlib</code>을 가져올 것입니다.</p>
<div id="cell-6" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:35}}" data-outputid="1f0b19d0-6e96-4cc9-b8e6-7adcb3f1da27" data-execution_count="2">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch <span class="im">import</span> nn <span class="co"># nn에는 신경망을 위한 PyTorch의 모든 구성 요소가 들어 있습니다.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># PyTorch 버전 확인</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>torch.__version__</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>'1.11.0'</code></pre>
</div>
</div>
</section>
<section id="데이터-준비-및-로드" class="level2">
<h2 class="anchored" data-anchor-id="데이터-준비-및-로드">1. 데이터 (준비 및 로드)</h2>
<p>머신러닝에서 “데이터”는 상상할 수 있는 거의 모든 것이 될 수 있다는 점을 강조하고 싶습니다. 숫자 표(큰 Excel 스프레드시트와 같은 것), 모든 종류의 이미지, 비디오(YouTube에는 데이터가 많습니다!), 노래나 팟캐스트와 같은 오디오 파일, 단백질 구조, 텍스트 등입니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/01-machine-learning-a-game-of-two-parts.png" class="img-fluid figure-img"></p>
<figcaption>머신러닝은 두 부분으로 구성된 게임입니다: 1. 데이터를 대표하는 숫자 집합으로 변환하고 2. 해당 표현을 가능한 한 잘 학습할 모델을 구축하거나 선택합니다.</figcaption>
</figure>
</div>
<p>머신러닝은 두 부분으로 나뉩니다: 1. 데이터를 숫자로 변환하여 표현합니다. 2. 해당 표현을 가장 잘 학습할 수 있는 모델을 선택하거나 구축합니다.</p>
<p>때로는 1번과 2번이 동시에 수행될 수도 있습니다.</p>
<p>하지만 데이터가 없다면 어떻게 할까요?</p>
<p>글쎄요, 그것이 지금 우리의 상황입니다.</p>
<p>데이터가 없습니다.</p>
<p>하지만 우리는 데이터를 직접 만들 수 있습니다.</p>
<p>데이터를 직선으로 만들어 봅시다.</p>
<p><a href="https://en.wikipedia.org/wiki/Linear_regression">선형 회귀(linear regression)</a>를 사용하여 알려진 <strong>파라미터(parameters)</strong>(모델이 학습할 수 있는 것들)를 가진 데이터를 생성한 다음, PyTorch를 사용하여 <a href="https://en.wikipedia.org/wiki/Gradient_descent"><strong>경사 하강법(gradient descent)</strong></a>을 통해 이러한 파라미터를 추정하는 모델을 구축할 수 있는지 확인해 보겠습니다.</p>
<div id="cell-8" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="ef7c9d50-31d6-47b6-add9-2cd51694298f" data-execution_count="3">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># *알려진* 파라미터 생성</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>weight <span class="op">=</span> <span class="fl">0.7</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>bias <span class="op">=</span> <span class="fl">0.3</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 데이터 생성</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>step <span class="op">=</span> <span class="fl">0.02</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> torch.arange(start, end, step).unsqueeze(dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> weight <span class="op">*</span> X <span class="op">+</span> bias</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>X[:<span class="dv">10</span>], y[:<span class="dv">10</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>(tensor([[0.0000],
         [0.0200],
         [0.0400],
         [0.0600],
         [0.0800],
         [0.1000],
         [0.1200],
         [0.1400],
         [0.1600],
         [0.1800]]),
 tensor([[0.3000],
         [0.3140],
         [0.3280],
         [0.3420],
         [0.3560],
         [0.3700],
         [0.3840],
         [0.3980],
         [0.4120],
         [0.4260]]))</code></pre>
</div>
</div>
<p>멋지네요! 이제 <code>X</code> (<strong>특성, features</strong>)와 <code>y</code> (<strong>레이블, labels</strong>) 사이의 관계를 학습할 수 있는 모델을 구축해 보겠습니다.</p>
<section id="데이터를-훈련-세트와-테스트-세트로-분할하기" class="level3">
<h3 class="anchored" data-anchor-id="데이터를-훈련-세트와-테스트-세트로-분할하기">데이터를 훈련 세트와 테스트 세트로 분할하기</h3>
<p>데이터가 준비되었습니다.</p>
<p>하지만 모델을 구축하기 전에 데이터를 분할해야 합니다.</p>
<p>머신러닝 프로젝트에서 가장 중요한 단계 중 하나는 훈련 세트와 테스트 세트(필요한 경우 검증 세트까지)를 만드는 것입니다.</p>
<p>데이터셋의 각 분할은 특정 목적을 위해 사용됩니다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>분할</th>
<th>목적</th>
<th>전체 데이터의 비율</th>
<th>얼마나 자주 사용되나요?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>훈련 세트(Training set)</strong></td>
<td>모델이 이 데이터로부터 학습합니다(학기 중에 공부하는 교재와 같음).</td>
<td>~60-80%</td>
<td>항상</td>
</tr>
<tr class="even">
<td><strong>검증 세트(Validation set)</strong></td>
<td>모델이 이 데이터에서 튜닝됩니다(기말고사 전에 치르는 모의고사와 같음).</td>
<td>~10-20%</td>
<td>자주(항상은 아님)</td>
</tr>
<tr class="odd">
<td><strong>테스트 세트(Testing set)</strong></td>
<td>모델이 학습한 내용을 테스트하기 위해 이 데이터에서 평가됩니다(학기 말에 치르는 기말고사와 같음).</td>
<td>~10-20%</td>
<td>항상</td>
</tr>
</tbody>
</table>
<p>지금은 훈련 세트와 테스트 세트만 사용할 것이며, 이는 우리 모델이 학습하고 평가될 데이터셋을 갖게 됨을 의미합니다.</p>
<p><code>X</code> 및 <code>y</code> 텐서를 분할하여 생성할 수 있습니다.</p>
<blockquote class="blockquote">
<p><strong>참고:</strong> 실제 데이터를 다룰 때 이 단계는 일반적으로 프로젝트 시작 시점에 수행됩니다(테스트 세트는 항상 다른 모든 데이터와 분리되어 보관되어야 합니다). 우리는 모델이 훈련 데이터에서 학습하도록 하고 테스트 데이터에서 평가하여 보지 못한 예제에 대해 얼마나 잘 <strong>일반화(generalizes)</strong>되는지 확인하고 싶습니다.</p>
</blockquote>
<div id="cell-11" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="a859f5c1-37ed-4a9a-b139-20a1107077ed" data-execution_count="4">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 훈련/테스트 분할 생성</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>train_split <span class="op">=</span> <span class="bu">int</span>(<span class="fl">0.8</span> <span class="op">*</span> <span class="bu">len</span>(X)) <span class="co"># 데이터의 80%를 훈련 세트로, 20%를 테스트용으로 사용</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>X_train, y_train <span class="op">=</span> X[:train_split], y[:train_split]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>X_test, y_test <span class="op">=</span> X[train_split:], y[train_split:]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(X_train), <span class="bu">len</span>(y_train), <span class="bu">len</span>(X_test), <span class="bu">len</span>(y_test)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>(40, 40, 10, 10)</code></pre>
</div>
</div>
<p>좋습니다. 훈련용 샘플 40개(<code>X_train</code> &amp; <code>y_train</code>)와 테스트용 샘플 10개(<code>X_test</code> &amp; <code>y_test</code>)를 확보했습니다.</p>
<p>우리가 만들 모델은 <code>X_train</code>과 <code>y_train</code> 사이의 관계를 학습하려고 노력할 것이며, 그런 다음 <code>X_test</code>와 <code>y_test</code>에서 학습한 내용을 평가할 것입니다.</p>
<p>하지만 지금 우리 데이터는 단지 페이지 위의 숫자에 불과합니다.</p>
<p>데이터를 시각화하는 함수를 만들어 보겠습니다.</p>
<div id="cell-13" class="cell" data-execution_count="5">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_predictions(train_data<span class="op">=</span>X_train, </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>                     train_labels<span class="op">=</span>y_train, </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                     test_data<span class="op">=</span>X_test, </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                     test_labels<span class="op">=</span>y_test, </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>                     predictions<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">  훈련 데이터와 테스트 데이터를 플롯하고 예측값과 비교합니다.</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">  """</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">7</span>))</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 훈련 데이터를 파란색으로 플롯</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>  plt.scatter(train_data, train_labels, c<span class="op">=</span><span class="st">"b"</span>, s<span class="op">=</span><span class="dv">4</span>, label<span class="op">=</span><span class="st">"훈련 데이터"</span>)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 테스트 데이터를 초록색으로 플롯</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>  plt.scatter(test_data, test_labels, c<span class="op">=</span><span class="st">"g"</span>, s<span class="op">=</span><span class="dv">4</span>, label<span class="op">=</span><span class="st">"테스트 데이터"</span>)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> predictions <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 예측값을 빨간색으로 플롯 (예측은 테스트 데이터에서 수행됨)</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    plt.scatter(test_data, predictions, c<span class="op">=</span><span class="st">"r"</span>, s<span class="op">=</span><span class="dv">4</span>, label<span class="op">=</span><span class="st">"예측값"</span>)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 범례 표시</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>  plt.legend(prop<span class="op">=</span>{<span class="st">"size"</span>: <span class="dv">14</span>})<span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-14" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:428}}" data-outputid="0d02d134-f6de-4e6f-c904-b081c7d6b8b1" data-execution_count="6">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>plot_predictions()<span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="01_pytorch_workflow_files/figure-html/cell-7-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>멋지네요!</p>
<p>이제 데이터는 페이지 위의 단순한 숫자가 아니라 직선이 되었습니다.</p>
<blockquote class="blockquote">
<p><strong>참고:</strong> 이제 데이터 탐험가의 좌우명인 “시각화, 시각화, 시각화!”를 소개할 좋은 시간입니다.</p>
<p>데이터를 다루고 숫자로 변환할 때마다 시각화할 수 있는 것이 있다면 이해하는 데 큰 도움이 된다는 점을 기억하세요.</p>
<p>기계는 숫자를 좋아하고 우리 인간도 숫자를 좋아하지만, 우리는 무언가를 보는 것도 좋아합니다.</p>
</blockquote>
</section>
</section>
<section id="모델-구축" class="level2">
<h2 class="anchored" data-anchor-id="모델-구축">2. 모델 구축</h2>
<p>이제 데이터가 준비되었으니 파란색 점을 사용하여 초록색 점을 예측할 모델을 구축해 보겠습니다.</p>
<p>바로 들어가 보겠습니다.</p>
<p>먼저 코드를 작성한 다음 모든 것을 설명하겠습니다.</p>
<p>순수 PyTorch를 사용하여 표준 선형 회귀 모델을 복제해 봅시다.</p>
<div id="cell-17" class="cell" data-execution_count="7">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 선형 회귀 모델 클래스 생성</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> LinearRegressionModel(nn.Module): <span class="co"># &lt;- PyTorch의 거의 모든 것은 nn.Module입니다 (이것을 신경망 레고 블록이라고 생각하세요)</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>() </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.weights <span class="op">=</span> nn.Parameter(torch.randn(<span class="dv">1</span>, <span class="co"># &lt;- 무작위 가중치로 시작 (모델이 학습함에 따라 조정됨)</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>            requires_grad<span class="op">=</span><span class="va">True</span>, <span class="co"># &lt;- 경사 하강법으로 이 값을 업데이트할 수 있나요?</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>            dtype<span class="op">=</span>torch.<span class="bu">float</span> <span class="co"># &lt;- PyTorch는 기본적으로 float32를 선호합니다</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        ))</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bias <span class="op">=</span> nn.Parameter(torch.randn(<span class="dv">1</span>, <span class="co"># &lt;- 무작위 편향으로 시작 (모델이 학습함에 따라 조정됨)</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            requires_grad<span class="op">=</span><span class="va">True</span>, <span class="co"># &lt;- 경사 하강법으로 이 값을 업데이트할 수 있나요?</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>            dtype<span class="op">=</span>torch.<span class="bu">float</span> <span class="co"># &lt;- PyTorch는 기본적으로 float32를 선호합니다</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        ))</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># forward는 모델 내의 계산을 정의합니다</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x: torch.Tensor) <span class="op">-&gt;</span> torch.Tensor: <span class="co"># &lt;- "x"는 입력 데이터입니다 (예: 훈련/테스트 특성)</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.weights <span class="op">*</span> x <span class="op">+</span> <span class="va">self</span>.bias <span class="co"># &lt;- 이것이 선형 회귀 공식입니다 (y = m*x + b)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>위 코드에서 꽤 많은 일이 일어나고 있는데, 하나씩 분석해 봅시다.</p>
<blockquote class="blockquote">
<p><strong>리소스:</strong> 신경망을 구축하기 위해 파이썬 클래스를 사용할 것입니다. 파이썬 클래스 표기법이 낯설다면 <a href="https://realpython.com/python3-object-oriented-programming/">Real Python의 파이썬 3 객체 지향 프로그래밍 가이드</a>를 몇 번 읽어보시기를 권장합니다.</p>
</blockquote>
<section id="pytorch-모델-구축-필수-요소" class="level3">
<h3 class="anchored" data-anchor-id="pytorch-모델-구축-필수-요소">PyTorch 모델 구축 필수 요소</h3>
<p>PyTorch에는 상상할 수 있는 거의 모든 종류의 신경망을 만드는 데 사용할 수 있는 필수 모듈이 네 가지 정도 있습니다.</p>
<p><a href="https://pytorch.org/docs/stable/nn.html"><code>torch.nn</code></a>, <a href="https://pytorch.org/docs/stable/optim.html"><code>torch.optim</code></a>, <a href="https://pytorch.org/docs/stable/data.html#torch.utils.data.Dataset"><code>torch.utils.data.Dataset</code></a> 및 <a href="https://pytorch.org/docs/stable/data.html"><code>torch.utils.data.DataLoader</code></a>입니다. 지금은 처음 두 가지에 집중하고 나중에 다른 두 가지를 다룰 것입니다(그것들이 무엇을 하는지 추측할 수 있을 것입니다).</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>PyTorch 모듈</th>
<th>무엇을 하나요?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://pytorch.org/docs/stable/nn.html"><code>torch.nn</code></a></td>
<td>계산 그래프(본질적으로 특정 방식으로 실행되는 일련의 계산)를 위한 모든 구성 요소를 포함합니다.</td>
</tr>
<tr class="even">
<td><a href="https://pytorch.org/docs/stable/generated/torch.nn.parameter.Parameter.html#parameter"><code>torch.nn.Parameter</code></a></td>
<td><code>nn.Module</code>과 함께 사용할 수 있는 텐서를 저장합니다. <code>requires_grad=True</code>인 경우 경사(<a href="https://ml-cheatsheet.readthedocs.io/en/latest/gradient_descent.html"><strong>경사 하강법</strong></a>을 통해 모델 파라미터를 업데이트하는 데 사용됨)가 자동으로 계산되며, 이를 종종 “autograd”라고 합니다.</td>
</tr>
<tr class="odd">
<td><a href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module"><code>torch.nn.Module</code></a></td>
<td>모든 신경망 모듈의 기본 클래스로, 신경망의 모든 구성 요소는 이 클래스의 서브클래스입니다. PyTorch에서 신경망을 구축하는 경우 모델은 <code>nn.Module</code>을 상속해야 합니다. <code>forward()</code> 메서드 구현이 필요합니다.</td>
</tr>
<tr class="even">
<td><a href="https://pytorch.org/docs/stable/optim.html"><code>torch.optim</code></a></td>
<td>다양한 최적화 알고리즘을 포함합니다(이 알고리즘은 <code>nn.Parameter</code>에 저장된 모델 파라미터가 경사 하강법을 개선하고 손실을 줄이기 위해 어떻게 가장 잘 변해야 하는지 알려줍니다).</td>
</tr>
<tr class="odd">
<td><code>def forward()</code></td>
<td>모든 <code>nn.Module</code> 서브클래스는 <code>forward()</code> 메서드가 필요하며, 이는 특정 <code>nn.Module</code>로 전달된 데이터에 대해 수행될 계산을 정의합니다(예: 위의 선형 회귀 공식).</td>
</tr>
</tbody>
</table>
<p>위 내용이 복잡하게 들린다면 이렇게 생각해 보세요. PyTorch 신경망의 거의 모든 것은 <code>torch.nn</code>에서 나옵니다. * <code>nn.Module</code>은 더 큰 구성 요소(레이어)를 포함합니다. * <code>nn.Parameter</code>는 가중치 및 편향과 같은 작은 파라미터를 포함합니다(이들을 함께 결합하여 <code>nn.Module</code>을 만듭니다). * <code>forward()</code>는 더 큰 블록이 <code>nn.Module</code> 내에서 입력(데이터가 가득 찬 텐서)에 대해 계산을 수행하는 방법을 알려줍니다. * <code>torch.optim</code>은 입력 데이터를 더 잘 나타내기 위해 <code>nn.Parameter</code> 내의 파라미터를 개선하는 최적화 방법을 포함합니다.</p>
<p><img src="https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/01-pytorch-linear-model-annotated.png" class="img-fluid" alt="주석이 달린 PyTorch 선형 모델"> <em><code>nn.Module</code>을 상속하여 PyTorch 모델을 만드는 기본 구성 요소. <code>nn.Module</code>을 상속하는 객체의 경우 <code>forward()</code> 메서드가 정의되어야 합니다.</em></p>
<blockquote class="blockquote">
<p><strong>리소스:</strong> <a href="https://pytorch.org/tutorials/beginner/ptcheat.html">PyTorch Cheat Sheet</a>에서 이러한 필수 모듈과 그 사용 사례를 더 많이 확인해 보세요.</p>
</blockquote>
</section>
<section id="pytorch-모델의-내용-확인하기" class="level3">
<h3 class="anchored" data-anchor-id="pytorch-모델의-내용-확인하기">PyTorch 모델의 내용 확인하기</h3>
<p>이제 필수 요소를 살펴보았으니, 우리가 만든 클래스로 모델 인스턴스를 생성하고 <a href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.parameters"><code>.parameters()</code></a>를 사용하여 해당 파라미터를 확인해 보겠습니다.</p>
<div id="cell-21" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="cd999f12-2efd-4fe7-e449-d51ff98e5242" data-execution_count="8">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># nn.Parameter가 무작위로 초기화되므로 수동 시드 설정</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">42</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 모델의 인스턴스 생성 (이것은 nn.Parameter들을 포함하는 nn.Module의 서브클래스입니다)</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>model_0 <span class="op">=</span> LinearRegressionModel()</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 우리가 생성한 nn.Module 서브클래스 내의 nn.Parameter들을 확인</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(model_0.parameters())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>[Parameter containing:
 tensor([0.3367], requires_grad=True),
 Parameter containing:
 tensor([0.1288], requires_grad=True)]</code></pre>
</div>
</div>
<p><a href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.state_dict"><code>.state_dict()</code></a>를 사용하여 모델의 상태(모델이 포함하는 내용)를 가져올 수도 있습니다.</p>
<div id="cell-23" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="7e35b61c-371e-4d28-ae02-c1981afc1bbb" data-execution_count="9">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 명명된 파라미터 나열</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>model_0.state_dict()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>OrderedDict([('weights', tensor([0.3367])), ('bias', tensor([0.1288]))])</code></pre>
</div>
</div>
<p><code>model_0.state_dict()</code>에서 <code>weights</code> 및 <code>bias</code> 값이 무작위 부동 소수점 텐서로 나오는 것을 확인하셨나요?</p>
<p>이는 위에서 <code>torch.randn()</code>을 사용하여 초기화했기 때문입니다.</p>
<p>본질적으로 우리는 무작위 파라미터에서 시작하여 모델이 우리 데이터에 가장 잘 맞는 파라미터(직선 데이터를 만들 때 설정한 하드코딩된 <code>weight</code> 및 <code>bias</code> 값)로 업데이트되도록 하기를 원합니다.</p>
<blockquote class="blockquote">
<p><strong>연습:</strong> 위의 두 셀 위에서 <code>torch.manual_seed()</code> 값을 변경해보고, 가중치와 편향 값에 어떤 일이 일어나는지 확인해 보세요.</p>
</blockquote>
<p>우리 모델은 무작위 값으로 시작하기 때문에 지금은 예측 능력이 떨어집니다.</p>
</section>
<section id="torch.inference_mode를-사용하여-예측하기" class="level3">
<h3 class="anchored" data-anchor-id="torch.inference_mode를-사용하여-예측하기"><code>torch.inference_mode()</code>를 사용하여 예측하기</h3>
<p>이를 확인하기 위해 테스트 데이터 <code>X_test</code>를 전달하여 <code>y_test</code>를 얼마나 근접하게 예측하는지 볼 수 있습니다.</p>
<p>모델에 데이터를 전달하면 모델의 <code>forward()</code> 메서드를 거쳐 정의된 계산을 사용하여 결과가 생성됩니다.</p>
<p>예측을 해봅시다.</p>
<div id="cell-26" class="cell" data-execution_count="10">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 모델로 예측하기</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.inference_mode(): </span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    y_preds <span class="op">=</span> model_0(X_test)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 참고: 오래된 PyTorch 코드에서는 torch.no_grad()를 볼 수도 있습니다.</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co"># with torch.no_grad():</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co">#   y_preds = model_0(X_test)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>음?</p>
<p>예측을 수행하기 위해 <a href="https://pytorch.org/docs/stable/generated/torch.inference_mode.html"><code>torch.inference_mode()</code></a>를 <a href="https://realpython.com/python-with-statement/">컨텍스트 매니저</a>(<code>with torch.inference_mode():</code> 부분)로 사용한 것을 눈치채셨을 것입니다.</p>
<p>이름에서 알 수 있듯이, <code>torch.inference_mode()</code>는 추론(예측 수행)을 위해 모델을 사용할 때 사용됩니다.</p>
<p><code>torch.inference_mode()</code>는 예측을 수행할 때 <strong>순전파(forward-passes)</strong>(<code>forward()</code> 메서드를 통과하는 데이터)를 더 빠르게 만들기 위해 여러 가지(훈련에는 필요하지만 추론에는 필요하지 않은 경사 추적 등)를 끕니다.</p>
<blockquote class="blockquote">
<p><strong>참고:</strong> 오래된 PyTorch 코드에서는 추론을 위해 <code>torch.no_grad()</code>가 사용되는 것을 볼 수 있습니다. <code>torch.inference_mode()</code>와 <code>torch.no_grad()</code>는 비슷한 역할을 하지만, <code>torch.inference_mode()</code>가 더 최신 버전이며 잠재적으로 더 빠르고 권장됩니다. 자세한 내용은 <a href="https://twitter.com/PyTorch/status/1437838231505096708?s=20">PyTorch의 이 트윗</a>을 참조하세요.</p>
</blockquote>
<p>예측을 수행했습니다. 어떻게 생겼는지 확인해 봅시다.</p>
<div id="cell-28" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="2ce37ea3-6bc4-4e50-91ef-dcf53277dde7" data-execution_count="11">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 예측값 확인</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"테스트 샘플 수: </span><span class="sc">{</span><span class="bu">len</span>(X_test)<span class="sc">}</span><span class="ss">"</span>) </span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"수행된 예측 수: </span><span class="sc">{</span><span class="bu">len</span>(y_preds)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"예측값:</span><span class="ch">\n</span><span class="sc">{</span>y_preds<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Number of testing samples: 10
Number of predictions made: 10
Predicted values:
tensor([[0.3982],
        [0.4049],
        [0.4116],
        [0.4184],
        [0.4251],
        [0.4318],
        [0.4386],
        [0.4453],
        [0.4520],
        [0.4588]])</code></pre>
</div>
</div>
<p>테스트 샘플당 하나의 예측값이 있는 것을 확인하세요.</p>
<p>이는 우리가 사용하는 데이터의 종류 때문입니다. 우리의 직선의 경우 하나의 <code>X</code> 값이 하나의 <code>y</code> 값에 매핑됩니다.</p>
<p>하지만 머신러닝 모델은 매우 유연합니다. 하나의 <code>y</code> 값에 100개의 <code>X</code> 값이 매핑될 수도 있고, 2개, 3개 또는 10개의 <code>y</code> 값에 매핑될 수도 있습니다. 모든 것은 작업 중인 대상에 달려 있습니다.</p>
<p>우리 예측값은 여전히 페이지 위의 숫자입니다. 위에서 만든 <code>plot_predictions()</code> 함수로 시각화해 봅시다.</p>
<div id="cell-30" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:428}}" data-outputid="56bf8a4d-2365-4539-a8b7-9bfe606f5b93" data-execution_count="12">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>plot_predictions(predictions<span class="op">=</span>y_preds.cpu())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="01_pytorch_workflow_files/figure-html/cell-13-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>와! 빨간색 점들을 보세요. 초록색 점들과 거의 완벽하게 일치합니다. 에포크(epochs)를 늘린 것이 도움이 된 것 같네요.</p>
</section>
<section id="모델-저장-및-로드" class="level3">
<h3 class="anchored" data-anchor-id="모델-저장-및-로드">6.5 모델 저장 및 로드</h3>
<p>모델의 예측 결과가 만족스러우므로, 나중에 사용할 수 있도록 파일로 저장해 봅시다.</p>
<div id="cell-33" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="e43ada0c-c074-4b50-9207-fa01581b1d5f" data-execution_count="38">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. 모델 디렉토리 생성</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>MODEL_PATH <span class="op">=</span> Path(<span class="st">"models"</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>MODEL_PATH.mkdir(parents<span class="op">=</span><span class="va">True</span>, exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. 모델 저장 경로 생성</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>MODEL_NAME <span class="op">=</span> <span class="st">"01_pytorch_workflow_model_1.pth"</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>MODEL_SAVE_PATH <span class="op">=</span> MODEL_PATH <span class="op">/</span> MODEL_NAME</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. 모델 state dict 저장</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"모델 저장 경로: </span><span class="sc">{</span>MODEL_SAVE_PATH<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>torch.save(obj<span class="op">=</span>model_1.state_dict(), <span class="co"># state_dict()만 저장하면 모델의 학습된 파라미터만 저장됩니다.</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>           f<span class="op">=</span>MODEL_SAVE_PATH) </span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>모델 저장 경로: models/01_pytorch_workflow_model_1.pth</code></pre>
</div>
</div>
<p>모든 것이 잘 작동했는지 확인하기 위해 모델을 다시 로드해 봅시다.</p>
<p>다음 단계를 수행합니다: * <code>LinearRegressionModelV2()</code> 클래스의 새로운 인스턴스를 생성합니다. * <code>torch.nn.Module.load_state_dict()</code>를 사용하여 모델의 state dict를 로드합니다. * 코드의 장치 독립성을 보장하기 위해 모델의 새 인스턴스를 대상 장치(target device)로 보냅니다.</p>
<div id="cell-35" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="76f10046-cd42-4b39-a372-aa95227828e8" data-execution_count="39">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># LinearRegressionModelV2의 새로운 인스턴스 생성</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>loaded_model_1 <span class="op">=</span> LinearRegressionModelV2()</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 모델 state dict 로드</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>loaded_model_1.load_state_dict(torch.load(MODEL_SAVE_PATH))</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 모델을 대상 장치로 보냄 (데이터가 GPU에 있으면 예측을 위해 모델도 GPU에 있어야 합니다)</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>loaded_model_1.to(device)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"로드된 모델:</span><span class="ch">\n</span><span class="sc">{</span>loaded_model_1<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"장치 위의 모델:</span><span class="ch">\n</span><span class="sc">{</span><span class="bu">next</span>(loaded_model_1.parameters())<span class="sc">.</span>device<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>로드된 모델:
LinearRegressionModelV2(
  (linear_layer): Linear(in_features=1, out_features=1, bias=True)
)
장치 위의 모델:
cuda:0</code></pre>
</div>
</div>
<p>이제 로드된 모델을 평가하여 그 예측이 저장하기 전의 예측과 일치하는지 확인할 수 있습니다.</p>
<div id="cell-37" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="c8184cd1-595a-43e4-8155-89dcecc4d0b0" data-execution_count="40">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 로드된 모델 평가</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>loaded_model_1.<span class="bu">eval</span>()</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.inference_mode():</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    loaded_model_1_preds <span class="op">=</span> loaded_model_1(X_test)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>y_preds <span class="op">==</span> loaded_model_1_preds</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="40">
<pre><code>tensor([[True],
        [True],
        [True],
        [True],
        [True],
        [True],
        [True],
        [True],
        [True],
        [True]], device='cuda:0')</code></pre>
</div>
</div>
<p>모든 것이 일치합니다! 좋습니다!</p>
<p>먼 길을 오셨습니다. 이제 PyTorch에서 처음 두 개의 신경망 모델을 직접 구축하고 훈련했습니다!</p>
<p>이제 실력을 연습해 볼 시간입니다.</p>
</section>
</section>
<section id="연습-문제" class="level2">
<h2 class="anchored" data-anchor-id="연습-문제">연습 문제</h2>
<p>모든 연습 문제는 노트북 전체의 코드에서 영감을 얻었습니다.</p>
<p>주요 섹션당 하나의 연습 문제가 있습니다.</p>
<p>해당 섹션을 참조하여 완료할 수 있어야 합니다.</p>
<blockquote class="blockquote">
<p><strong>참고:</strong> 모든 연습 문제에서 코드는 장치 독립적이어야 합니다(즉, 사용 가능한 경우 CPU 또는 GPU에서 실행될 수 있어야 함).</p>
</blockquote>
<ol type="1">
<li>선형 회귀 공식(<code>weight * X + bias</code>)을 사용하여 직선 데이터셋을 만듭니다.</li>
</ol>
<ul>
<li><code>weight=0.3</code>, <code>bias=0.9</code>로 설정하고 총 데이터 포인트는 100개 이상이어야 합니다.</li>
<li>데이터를 훈련 80%, 테스트 20%로 분할합니다.</li>
<li>훈련 및 테스트 데이터를 시각적으로 플롯합니다.</li>
</ul>
<ol start="2" type="1">
<li><code>nn.Module</code>을 상속하여 PyTorch 모델을 구축합니다.</li>
</ol>
<ul>
<li>내부에는 무작위로 초기화된 <code>nn.Parameter()</code>가 있어야 하며, 하나는 가중치(<code>weights</code>)용, 하나는 편향(<code>bias</code>)용이고 <code>requires_grad=True</code>여야 합니다.</li>
<li>1번에서 데이터셋을 만드는 데 사용한 선형 회귀 함수를 계산하도록 <code>forward()</code> 메서드를 구현합니다.</li>
<li>모델을 구성한 후 인스턴스를 만들고 <code>state_dict()</code>를 확인합니다.</li>
<li><strong>참고:</strong> 원한다면 <code>nn.Parameter()</code> 대신 <code>nn.Linear()</code>를 사용할 수 있습니다.</li>
</ul>
<ol start="3" type="1">
<li>각각 <code>nn.L1Loss()</code> 및 <code>torch.optim.SGD(params, lr)</code>를 사용하여 손실 함수와 옵티마이저를 생성합니다.</li>
</ol>
<ul>
<li>옵티마이저의 학습률을 0.01로 설정하고, 최적화할 파라미터는 2번에서 만든 모델의 모델 파라미터여야 합니다.</li>
<li>300 에포크 동안 적절한 훈련 단계를 수행하는 훈련 루프를 작성합니다.</li>
<li>훈련 루프는 20 에포크마다 테스트 데이터셋에서 모델을 테스트해야 합니다.</li>
</ul>
<ol start="4" type="1">
<li>훈련된 모델로 테스트 데이터에 대해 예측을 수행합니다.</li>
</ol>
<ul>
<li>이러한 예측값을 원래 훈련 및 테스트 데이터와 함께 시각화합니다 (<strong>참고:</strong> matplotlib과 같이 CUDA를 지원하지 않는 라이브러리를 사용하여 플롯하려면 예측값이 GPU에 있지 않은지 확인해야 할 수 있습니다).</li>
</ul>
<ol start="5" type="1">
<li>훈련된 모델의 <code>state_dict()</code>를 파일로 저장합니다.</li>
</ol>
<ul>
<li>2번에서 만든 모델 클래스의 새로운 인스턴스를 생성하고 방금 저장한 <code>state_dict()</code>를 로드합니다.</li>
<li>로드된 모델로 테스트 데이터에 대해 예측을 수행하고 4번의 원래 모델 예측과 일치하는지 확인합니다.</li>
</ul>
<blockquote class="blockquote">
<p><strong>리소스:</strong> 이 과정의 GitHub에서 <a href="https://github.com/mrdbourke/pytorch-deep-learning/tree/main/extras/exercises">연습 문제 노트북 템플릿</a> 및 <a href="https://github.com/mrdbourke/pytorch-deep-learning/tree/main/extras/solutions">솔루션</a>을 참조하세요.</p>
</blockquote>
</section>
<section id="추가-학습-자료" class="level2">
<h2 class="anchored" data-anchor-id="추가-학습-자료">추가 학습 자료</h2>
<ul>
<li><a href="https://youtu.be/Nutpusq_AFw">비공식 PyTorch 최적화 루프 송(The Unofficial PyTorch Optimization Loop Song)</a>을 들어보세요 (PyTorch 훈련/테스트 루프의 단계를 기억하는 데 도움이 됨).</li>
<li>PyTorch에서 가장 중요한 모듈 중 하나가 어떻게 작동하는지 더 깊이 이해하려면 Jeremy Howard의 <a href="https://pytorch.org/tutorials/beginner/nn_tutorial.html">What is <code>torch.nn</code>, really?</a>를 읽어보세요.</li>
<li>접할 수 있는 다양한 PyTorch 모듈에 대해 <a href="https://pytorch.org/tutorials/beginner/ptcheat.html">PyTorch 문서 치트시트(cheatsheet)</a>를 10분 정도 훑어보세요.</li>
<li>PyTorch의 다양한 저장 및 로드 옵션에 익숙해지기 위해 <a href="https://pytorch.org/tutorials/beginner/saving_loading_models.html">PyTorch 웹사이트의 로딩 및 저장 문서</a>를 10분 정도 읽어보세요.</li>
<li>우리 모델의 학습을 돕기 위해 백그라운드에서 작동해 온 두 가지 주요 알고리즘인 경사 하강법과 역전파의 내부 구조에 대한 개요를 위해 다음 자료를 1~2시간 동안 읽거나 시청하세요.</li>
<li><a href="https://en.wikipedia.org/wiki/Gradient_descent">Wikipedia의 경사 하강법 페이지</a></li>
<li>Robert Kwiatkowski의 <a href="https://towardsdatascience.com/gradient-descent-algorithm-a-deep-dive-cf04e8115f21">Gradient Descent Algorithm — a deep dive</a></li>
<li>3Blue1Brown의 <a href="https://youtu.be/IHZwWFHWa-w">경사 하강법, 신경망은 어떻게 학습하는가 비디오</a></li>
<li>3Blue1Brown의 <a href="https://youtu.be/Ilg3gGewQ5U">역전파는 실제로 무엇을 하고 있는가?</a> 비디오</li>
<li><a href="https://en.wikipedia.org/wiki/Backpropagation">역전파(Backpropagation) Wikipedia 페이지</a></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./00_pytorch_fundamentals.html" class="pagination-link" aria-label="00 - PyTorch 기초">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-title">00 - PyTorch 기초</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./02_pytorch_classification.html" class="pagination-link" aria-label="02 - PyTorch 신경망 분류">
        <span class="nav-page-text"><span class="chapter-title">02 - PyTorch 신경망 분류</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>